## code

```js
/**
 * @param {number[]} nums
 * @return {number}
 */
var maxProduct = function (nums) {

        const min_dp = [nums[0]]
        const max_dp = [nums[0]]
        let maxProductRes = nums[0]
        for (let i = 1; i < nums.length; i++) {
            const curValue = nums[i]
            max_dp[i] = Math.max(curValue, max_dp[i - 1] * curValue, min_dp[i - 1] * curValue)
            min_dp[i] = Math.min(curValue, max_dp[i - 1] * curValue, min_dp[i - 1] * curValue)
            maxProductRes = Math.max(max_dp[i], min_dp[i],maxProductRes)
            //  打擂台维护最大值
        }
        return maxProductRes;
    };



// 1. [2,3,-2,4] 连续子数组：[2,3] ✅ [2,4] ❎

// 2. 最小号问题：一个元素的乘积是多少？ 是自身

// 3. 最终问题：n个元素的乘积最大值，要考虑正负问题。


// 假设全部为正整数

// dp[n] = Max(max,dp[0 ~ i])

// 包含负数

// 负数 * 负数（历史最小的负数） -> 正数，可以和历史最大的正数 进行battle

// [2,3,-2,4]
// dp_max     2  6 -12 -48

// dp_min    2  3  

// dp_max[i] = if(num[i] > 0)
//             Max(dp_max[i - 1] * num[i],num[i])
//           else 
//             Max(dp_min[i - 1] * num[i],num[i])


// dp_min[i] = if(num[i] > 0)
//             Min(dp_min[i - 1] * num[i],num[i])
//           else 
//             Min(dp_max[i - 1] * num[i],num[i])


// 合并状态变更逻辑

// ...
```