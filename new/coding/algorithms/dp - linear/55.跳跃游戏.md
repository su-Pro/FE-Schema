# [55. 跳跃游戏](https://leetcode-cn.com/problems/jump-game/)

## solutions

1. ***最小号问题***：len - 1 不需要跳即可到达最后一个下标。
2. ***problem growing***:
	- idx:3 (1) 可以跳到？
	nums[3] + 3 => 4 === idx:4(目标位置) T
	- idx:2 (1) 可以跳到？
	nums[2] + 2 => 3 === idx:3 (历史上已经check过的最近元素) T
	- ...
3. ***m[i] represent what ?***:当前位置是否可以到达最后一个元素
4. *** m[i] = ?***
	- case : True
		nums[i] + i >= targetIdx
	- case : False
		nums[i] + i < targetIdx
5. ***最终返回m[0]***

```js
/**
 * @param {number[]} nums
 * @return {boolean}
 */
var canJump = function(nums) {

    const len = nums.length;
    const dp = new Array(len).fill(false);
    let targetIdx = len - 1;

    dp[len - 1] = true;

    for(let i = len - 2;i >= 0;i--) {

        if(nums[i] + i < targetIdx) {
            continue;
        }

        dp[i] = true;
        targetIdx = i;
        
    }
    return dp[0]
};
```

***优化：***

```js
var canJump = function(nums) {
    const len = nums.length;
    // 初始检查目标索引
    let targetIdx = len - 1;

    for(let i = len - 2;i >= 0;i--) {
        if(nums[i] + i < targetIdx) {
            continue;
        }
        targetIdx = i;
    }
    return targetIdx === 0;
};
```

## fllow up 
[[45.跳跃游戏 II]]