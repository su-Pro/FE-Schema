## 说说你对超时重传的理解

TCP的可靠传输特点决定了当出现丢包时，会进行重传与确认，从而保证每一个segment段准确送达到对方手中。

在传输过程中，可能发生报文丢失导致没有准确送达到对方手中。

![20200610152428]( https://supyyy-1259673491.cos.ap-beijing.myqcloud.com/2020/pictures20200610152428.png)

### PAR

这是最早的解决方案，核心思想是每次发送请求后会开启一个定时器，如果在定时器达到时间后还没有收到ACK，会进行重传操作。

存在**效率低**的问题：串行发送请求，一个消息对应一个定时器，必须当前消息准确送达后，才能发送第二个消息。

![20200610152509]( https://supyyy-1259673491.cos.ap-beijing.myqcloud.com/2020/pictures20200610152509.png)

### 提升并发能力的 PAR 改进版

1. 通过#标识唯一消息，发送端发送#消息，接收端也需要回复对应#标识的ACK因此可以并发发送消息。
2. 通过Limit 限制发送方实现对接收缓冲区的管理，避免一次并发太多请求。

![20200610152858]( https://supyyy-1259673491.cos.ap-beijing.myqcloud.com/2020/pictures20200610152858.png)

### RTO和RTT

当发生segment丢失后，需要根据定时器设置的超时时间进行重传，也就是RTO，关于RTO的大小是需要参考RTT值进行设置的。

> 接下来简单解释一下RTT和他算法

### RTT

RTT就是一个数据包从发送端发出，到接收端返回ACK的整个耗时过程。

![20200610153253]( https://supyyy-1259673491.cos.ap-beijing.myqcloud.com/2020/pictures20200610153253.png)

#### 简单差值计算RTT

发送消息的sequence中是有一个时间戳的，收到消息确认的ACK中也是有一个时间戳的（TCB）中，两者做一个差值，就是RTT。

#### 重传场景复杂场景下计算RTT

一旦发生丢包或者网络延时后，计算RTT就变得十分复杂，如下两种情况

![20200610154019]( https://supyyy-1259673491.cos.ap-beijing.myqcloud.com/2020/pictures20200610154019.png)

a：当发送一个请求后，在ACK返回途中由于网络延迟导致意外判定为丢包现象，随后进行重发报文。此时的RTT就会以重新发送的报文为开始时刻，当ACK姗姗来迟后认为此报文就是重传后对应的ACK，会以这个时间进行RTT计算。显然是偏小的。

b：当发送一个数据包后，不料网络原因被确定为丢包，立刻会会进行重传，此时的ACK计算会按照从最初的消息到重传后的ack到达时间计算，显然是偏大的。

**因此引出了计算RTT的第2种方法：Timestamp**

> 数据包中 Timestamp 选项的回显时间

#### RTO

RTO 应当略大于 RTT,如果小于RTT会导致每次发送都会有重传...如果大于RTT太多会导致重传时的效率问题。

 ![20200610154834]( https://supyyy-1259673491.cos.ap-beijing.myqcloud.com/2020/pictures20200610154834.png)
