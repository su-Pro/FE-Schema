## 知道TCP的keepalive机制吗？

一个 TCP 连接上，如果通信双方都不向对方发送数据，那么 TCP 连接就不会有任何数据交换。但是会占用大量的内存用于保持连接状态，如果有一方已经宕机或者意外关闭连接另一方是不之情的，因此这样会导致资源的大量浪费。

### 场景

假设应用程序是一个 web 服务器，客户端发出三次握手以后故障宕机或被踢掉网线，对于 web 服务器而已，下一个数据包将永远无法到来，但是它一无所知。并且TCP 不会采用类似于轮询的方式来询问对方是否有数据发送过来。

![20200610112958]( https://supyyy-1259673491.cos.ap-beijing.myqcloud.com/2020/pictures20200610112958.png)

### TCP： keeplive

TCP 协议的设计者考虑到了这种检测长时间死连接的需求，于是乎设计了 keepalive 机制。 在 CentOS 机器上，keepalive 探测包发送数据 7200s，探测 9 次，每次探测间隔 75s，这些值都有对应的参数可以配置。

```
发送心跳周期
  Linux: net.ipv4.tcp_keepalive_time = 7200
探测包发送间隔
  net.ipv4.tcp_keepalive_intvl = 75
探测包重试次数
  net.ipv4.tcp_keepalive_probes = 9
```

当达到tcp_keepalive的检测阀值后，会按照时间间隔发送探测包，检查对方是否处于“健康状态”。如果尝试探测包重发已达到上限后，服务端觉得没有希望了发出 RST 包，主动断掉这个连接.
