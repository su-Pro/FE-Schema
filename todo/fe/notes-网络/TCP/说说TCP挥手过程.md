## 说说 TCP 挥手过程？

### 断开连接过程

1. 客户端调用 close 方法，执行「主动关闭」，会发送一个 FIN 报文给服务端（从这以后客户端不能再发送数据给服务端），客户端进入 FIN-WAIT-1 状态。

> 主动发起关闭的一方称为「主动关闭方」，另外一段称为「被动关闭方」。

2. 服务端收到 FIN 包以后回复确认 ACK 报文给客户端，服务端进入 CLOSE_WAIT，客户端收到 ACK 以后进入 FIN-WAIT-2 状态。

3. 服务端也没有数据要发送了，发送 FIN 报文给客户端，然后进入 LAST-ACK 状态，等待客户端的 ACK。

4. 客户端收到服务端的 FIN 报文以后，回复 ACK 报文用来确认第三步里的 FIN 报文，进入TIME_WAIT 状态，**等待 2 个 MSL** 以后进入 CLOSED 状态。服务端收到 ACK 以后进入 CLOSED 状态。

![20200610113703]( https://supyyy-1259673491.cos.ap-beijing.myqcloud.com/2020/pictures20200610113703.png)

### 延时确认“三次握手断开连接”

因为有延迟确认的存在，把第二步的 ACK 经常会跟随第三步的 FIN 包一起捎带会对端，所以是存在三次断开连接场景的。

![20200610114442]( https://supyyy-1259673491.cos.ap-beijing.myqcloud.com/2020/pictures20200610114442.png)

TODO: 延迟确认锚点

### TIME-WAIT状态

#### MSL是什么？

MSL（报文最大生存时间）是 TCP **报文在网络中的最大生存时间**，这个值与 IP 报文头的 TTL 字段有密切的关系。IP 报文头中有一个 8 位的存活时间字段，（Time to live, TTL） 这个存活时间存储的不是具体的时间，而是一个 IP 报文最大可经过的路由数，每经过一个路由器，TTL 减 1，当 TTL 减到 0 时这个 IP 报文会被丢弃。

![20200610115007]( https://supyyy-1259673491.cos.ap-beijing.myqcloud.com/2020/pictures20200610115007.png)

从上面可以看到 TTL 说的是「跳数」限制而不是「时间」限制，尽管如此我们依然**假设最大跳数的报文在网络中存活的时间不可能超过 MSL 秒**。Linux 的套接字实现假设 MSL 为 30 秒，因此在 Linux 机器上 TIME_WAIT 状态将持续 60秒。

#### 为什么需要TIME-WAIT阶段？

1. ：报文传输中存在**延迟到达**的可能性，需要等到延迟到达的报文准确送达后才能关闭。否则会在**端口复用**（四元组）时所创建新连接时收到旧连接姗姗来迟的数据包，造成**数据错乱**。

![20200610115226]( https://supyyy-1259673491.cos.ap-beijing.myqcloud.com/2020/pictures20200610115226.png)

2. ： 确保可靠实现 TCP 全双工终止连接。关闭连接的四次挥手中，最终的 ACK 由主动关闭方发出，如果这个 ACK 丢失，对端（被动关闭方）将重发 FIN，如果主动关闭方不维持 TIME_WAIT 直接进入 CLOSED 状态，则无法重传 ACK，被动关闭方因此不能及时可靠释放。

![20200610115410]( https://supyyy-1259673491.cos.ap-beijing.myqcloud.com/2020/pictures20200610115410.png)

#### 为什么是两个MSL？

- 1 个 MSL 确保四次挥手中主动关闭方最后的 ACK 报文最终能达到对端
- 1 个 MSL 确保对端没有收到 ACK 重传的 FIN 报文可以到达

2MS = 去向 ACK 消息最大存活时间（MSL) + 来向 FIN 消息的最大存活时间（MSL