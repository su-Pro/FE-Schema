## 请求方法 和 常见状态码

### 请求方法

Http/1.1 规定了八种方法，单词必须都是大写的形式。

1. GET:获取资源，可以理解为读取或者下载数据
2. HEAD:获取资源的元信息;
3. POST:向资源提交数据，相当于写入或上传数据;
4. PUT:类似 POST;
5. DELETE:删除资源;
6. CONNECT:建立特殊的连接隧道;
7. OPTIONS:列出可对资源实行的方法;
8. TRACE:追踪请求-响应的传输路径。

**GET/HEAD**
——从服务器获取资源
HEAD 和 GET 类似，也是从服务器获取资源，但是不会返回请求的实体数据，只有响应头（元信息），是 GET 的简易版，如果不需要资源的话，可以避免传输 body 数据的浪费。

> HEAD 通常用在 CORS预检请求 中

**POST/PUT**
——向服务器提交数据，数据在 body 里；PUT 和 POST 作用类似，有微妙不同，通常 POST 标识新建，PUT 标识修改

**OPTIONS**
——要求服务器列出可对资源实行的操作方法，在响应头 Allow 字段里返回。（主要用于跨域 CORS 处理）

DELETE
——删除资源，危险性大，很少用

CONNECT
——要求服务器为客户端和另一台远程服务器建立一条特殊的链接，这时 Web 服务器充当代理的角色

TRACE
——用于对 HTTP 链路的测试或诊断，可以显示出请求 - 响应的传输路径。存在漏洞，会泄露网站的信息，所以通常也是禁止使用

#### 安全与幂等

安全：在 HTTP 协议里，所谓的安全，是指请求方法不会对服务器上的资源造成实质的修改，所有 只有 GET 和 HEAD 是安全的，因为是只读操作。

幂等：**多次执行相同的操作，结果也都是相同的（类似纯函数）**。

GET 和 HEAD 即是安全的也是幂等的，DELETE 可以多次删除同一个资源，效果都是“资源不存在”，所以也是幂等。

POST 是新增或提交数据，多次提交会创建多个资源，所以不是幂等的。

PUT 是替换或更新数据，多次更新一个资源，资源还是第一次更新的状态。所以是幂等的。

幂等：GET、HEAD、DELETE、PUT
非幂等：POST

#### get 和 post 的区别

#### 语义

GET：获取资源，可以理解为读取或者下载数据

POST：向资源提交数据，相当于写入或上传数据

#### 幂等与缓存

**get**：“读取“一个资源。比如 Get 到一个 html 文件。反复读取不应该对访问的数据有副作用。比如”GET 一下，用户就下单了，返回订单已受理“，这是不可接受的。没有副作用被称为“幂等“（Idempotent)。因为 GET 因为是读取，就可以对 GET 请求的数据做缓存。这个缓存可以做到浏览器本身上（彻底避免浏览器发请求），也可以做到代理上（如 nginx），或者做到 server 端（用 Etag，至少可以减少带宽消耗）

**post**：不幂等也就意味着不能随意多次执行。因此也就不能缓存。比如通过 POST 下一个单，服务器创建了新的订单，然后返回订单成功的界面。这个页面不能被缓存。

试想一下，如果 POST 请求被浏览器缓存了，那么下单请求就可以不向服务器发请求，而直接返回本地缓存的“下单成功界面”，却又没有真的在服务器下单。那是一件多么滑稽的事情。

> 这题是一个坑，谨慎回答多说无益（菜是原罪）

### 常见状态码说一下

具体有如下五类：

1××：提示信息，表示目前是协议处理的中间状态，还需要后续的操作；
2××：成功，报文已经收到并被正确处理；
3××：重定向，资源位置发生变动，需要客户端重新发送请求；
4××：客户端错误，请求报文有误，服务器无法处理；
5××：服务器错误，服务器在处理请求时内部发生了错误。

#### 1xx

1×× 类状态码属于提示信息，是协议处理的中间状态，实际能够用到的时候很少。

> 我们偶尔能够见到的是“101 Switching Protocols”。它的意思是客户端使用 Upgrade 头字段，要求在 HTTP 协议的基础上改成其他的协议继续通信，比如 WebSocket。而如果服务器也同意变更协议，就会发送状态码 101，但这之后的数据传输就不会再使用 HTTP 了。

#### 2xx

2×× 类状态码表示服务器收到并成功处理了客户端的请求，这也是客户端最愿意看到的状态码。

“200 OK”是最常见的成功状态码，表示一切正常，服务器如客户端所期望的那样返回了处理结果。非 HEAD 请求，通常在响应头后都会有 body 数据。

”201 Created“ 是一个代表成功的应答状态码，表示请求已经被成功处理，并且创建了新的资源。新的资源在应答返回之前已经被创建。同时新增的资源会在应答消息体中返回，其地址或者是原始请求的路径，或者是 Location 首部的值。

“204 No Content”是另一个很常见的成功状态码，它的含义与“200 OK”基本相同，但响应头后没有 body 数据。所以对于 Web 服务器来说，**正确地区分 200 和 204 是很必要的。**

“206 Partial Content”是 HTTP **分块下载**或**断点续传**的基础，在客户端发送“范围请求”、要求获取资源的部分数据时出现，它与 200 一样，也是服务器成功处理了请求，但 body 里的数据不是资源的全部，而是其中的一部分。

> 状态码 206 通常还会伴随着头字段“Content-Range”，表示响应报文里 body 数据的具体范围，供客户端确认，例如“Content-Range: bytes 0-99/2000”，意思是此次获取的是总计 2000 个字节的前 100 个字节。

#### 3xx

3×× 类状态码表示客户端请求的资源发生了变动，客户端必须用新的 URI 重新发送请求获取资源，也就是通常所说的“重定向”.

“301 Moved Permanently”俗称“永久重定向”

“302 Found”俗称“临时重定向”，意思是请求的资源还在，但需要暂时用另一个 URI 来访问。

“304 Not Modified” 它用于 If-Modified-Since 等条件请求。表示资源未修改，用于**缓存控制**。它不具有通常的跳转含义，但可以理解成“重定向已到缓存的文件”（即“缓存重定向”）。

#### 4xx

4×× 类状态码表示客户端**发送的请求报文**有误，**服务器无法处理**

“400 Bad Request”是一个通用的错误码，表示请求报文有错误，但具体是数据格式错误、缺少请求头还是 URI 超长它没有明确说，只是一个笼统的错误,后端开发时，别用，膈应人。

“401 Unauthorized 身份认证失败”

“403 Forbidden”实际上不是客户端的请求出错，而是表示服务器禁止访问资源（没权限）。

“404 Not Found”可能是我们最常看见也是最不愿意看到的一个状态码，它的原意是资源在本服务器上未找到，所以无法提供给客户端。

“405 Method Not Allowed”
“413 Request Entity Too Large”
“414 Request-URI Too Long”

> 服务端开发时，给 404 时一定要语义明确，尽量不给 web 开发人员造成负担。

#### 5xx

5×× 类状态码表示客户端请求报文正确，但服务器在处理时内部发生了错误，无法返回应有的响应数据，是服务器端的“错误码”。

“500 Internal Server Error”与 400 类似，也是一个通用的错误码，服务器究竟发生了什么错误我们是不知道的。

> 不过对于服务器来说这应该算是好事，通常不应该把服务器内部的详细信息，例如出错的函数调用栈告诉外界。

“501 Not Implemented”表示客户端请求的功能还不支持，这个错误码比 500 要“温和”一些，和“即将开业，敬请期待”的意思差不多

“503 Service Unavailable”表示服务器当前很忙，暂时无法响应服务，我们上网时有时候遇到的“网络服务正忙，请稍后重试”的提示信息就是状态码 503。

“502 Bad Gateway”通常是服务器作为网关或者代理时返回的错误码，表示服务器自身工作正常，访问后端服务器时发生了错误
