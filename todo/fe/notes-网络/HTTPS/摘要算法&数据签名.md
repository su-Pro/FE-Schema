## 摘要算法?和数据签名

- 哈希函数（哈希碰撞）
- 摘要算法：SHA2 摘要算法
- 数字签名：摘要算法 + 私钥
- 实现：完整性、不可否认性、身份确定性

### 摘要算法

实现完整性的手段主要是摘要算法（Digest Algorithm），也就是常说的散列函数、哈希函数（Hash Function）。

你可以把摘要算法近似地理解成一种特殊的压缩算法，它能够把任意长度的数据“压缩”成固定长度、而且独一无二的**摘要字符串**，就好像是给这段数据生成了一个数字“**指纹**”。

> 它只有算法，没有密钥，加密后的数据无法解密，不能从摘要逆推出原文。因此只能对比两份摘要是否相同判断有无被篡改

摘要算法实际上是把数据从一个“大空间”映射到了“小空间”，所以就存在“冲突”（collision，也叫碰撞）的可能性，**就如同现实中的指纹一样，可能会有两份不同的原文对应相同的摘要**。好的摘要算法必须能够“抵抗冲突”，让这种可能性尽量地小。

> 因为摘要算法对输入具有“单向性”和“雪崩效应”，输入的微小不同会导致输出的剧烈变化，所以也被 TLS 用来生成伪随机数

你一定在日常工作中听过、或者用过 **MD5**（Message-Digest 5）、**SHA-1**（Secure Hash Algorithm 1），它们就是最常用的两个摘要算法，能够生成 16 字节和 20 字节长度的数字摘要。但这两个算法的安全强度比较低，不够安全，**在 TLS 里已经被禁止使用**了。目前 TLS 推荐使用的是 SHA-1 的后继者：**SHA-2**。

> SHA-2 实际上是一系列摘要算法的统称，总共有 6 种，常用的有 SHA224、SHA256、SHA384，分别能够生成 28 字节、32 字节、48 字节的摘要。

**摘要算法保证了“数字摘要”和原文是完全等价的。所以，我们只要在原文后附上它的摘要，就能够保证数据的完整性**。

不过摘要算法不具有机密性，如果明文传输，那么黑客可以修改消息后把摘要也一起改了，网站还是鉴别不出完整性。

所以，真正的完整性必须要建立在机密性之上，在混合加密系统里用会话密钥加密消息和摘要。

### 数据签名

加密算法结合摘要算法，我们的通信过程可以说是比较安全了。但这里还有漏洞，就是通信的**两个端点**。

> 在 TLS 里有什么东西和现实中的签名、印章很像，只能由本人持有，而其他任何人都不会有呢？只要用这个东西，就能够在数字世界里证明你的身份。

这个东西就是非对称加密里的“私钥”，使用**私钥再加上摘要算法**，就能够实现“**数字签名**”，同时实现“**身份认证**”和“**不可否认**”。

> 数字签名的原理其实很简单，就是把公钥私钥的用法反过来，之前是公钥加密、私钥解密，现在是私钥加密、公钥解密。

但又因为非对称加密效率太低，所以**私钥只加密原文的摘要**，这样运算量就小的多，而且得到的数字签名也很小，方便保管和传输。

签名和公钥一样完全公开，任何人都可以获取。但这个签名只有用私钥对应的公钥才能解开，拿到摘要后，再比对原文验证完整性，就可以像签署文件一样证明消息确实是你发的。刚才的这两个行为也有专用术语，叫做“**签名**”和“**验签**”。
