## TLS 握手讲一下吧？

- 握手目的：为对称加密安全交换秘钥
- RSA 经典握手
- ECHDE 握手：ECDHE 算法参数交换、抢跑
- TLS1.3 握手：必须采用 ECHDE 算法，压缩为 1RTT

### 握手目的

**实现 HTTPS 通信的机密性**，在通信刚开始的时候使用非对称算法，比如 RSA、ECDHE，首先解决密钥交换的问题。然后用随机数产生对称算法使用的“**会话密钥**”（session key），再用公钥加密。
对方拿到密文后用私钥解密，取出会话密钥。这样，双方就实现了对称密钥的安全交换，后续就不再使用非对称加密，全都使用对称加密。

### RSA 握手过程

RSA 可能是加密算法中最著名的一个，几乎可以说是非对称加密的代名词，它的安全性基于“整数分解”的数学难题，使用两个超大素数的乘积作为生成密钥的材料，想要从公钥推算出私钥是非常困难的。

![](../../img/网络/HTTP/RSA加密算法.png)

大体上分为三个阶段：**明文共享阶段、CA 认证阶段、生成主秘钥阶段**

第一阶段：明文共享阶段

1. 在 TCP 建立连接之后，浏览器会首先发一个“Client Hello”消息，里面有客户端的版本号、支持的密码套件，还有一个随机数（Client Random），用于后续生成会话密钥。
2. 服务器收到“Client Hello”后，会返回一个“Server Hello”消息。把版本号对一下，也给出一个随机数（Server Random），然后从客户端的列表里选一个作为本次通信使用的密码套件以及公钥。
3. 服务器为了证明自己的身份，就把证书也发给了客户端（Server Certificate）。
4. Server Done

这样第一个消息往返就结束了（两个 TCP 包），结果是客户端和服务器通过明文共享了三个信息：Client Random、Server Random 和 公钥。

第二阶段：证书验证

客户端这时也拿到了服务器的证书，那这个证书是不是真实有效的呢？这就要用到第 25 讲里的知识了，开始走证书链逐级验证，确认证书的真实性，再用证书公钥验证签名，就确认了服务器的身份：“刚才跟我打招呼的不是骗子，可以接着往下走。”

第三阶段：主密钥生成

1. 客户端通过 RSA 公钥对生成的 pre-master 进行加密，并发送给服务端。
2. 现在客户端和服务器手里有了三个随机数：Client Random、Server Random 和 Pre-Master。用这三个作为原始材料，就可以生成用于加密会话的主密钥，叫“Master Secret”。
3. 有了主密钥和派生的会话密钥，客户端发一个“Change Cipher Spec”，然后再发一个“Finished”消息，把之前所有发送的数据做个摘要，再加密一下，让服务器做个验证。
4. 服务器也发送“Change Cipher Spec”和“Finished”消息，双方都验证加密解密 OK，握手正式结束，后面就收发被加密的 HTTP 请求和响应

### ECDHE 握手过程

第一阶段：明文共享阶段(C/S 两端共享随机数 和 服务器的椭圆曲线加密参数)

1. 在 TCP 建立连接之后，浏览器会首先发一个“Client Hello”消息，里面有客户端的版本号、支持的密码套件，还有一个随机数（Client Random），用于后续生成会话密钥。
2. 服务器收到“Client Hello”后，会返回一个“Server Hello”消息。把版本号对一下，也给出一个随机数（Server Random），然后从客户端的列表里选一个作为本次通信使用的密码套件。
3. 接下来是一个关键的操作，因为服务器选择了 ECDHE 算法，所以它会在证书后发送“Server Key Exchange”消息，里面是椭圆曲线的公钥（Server Params），用来实现密钥交换算法，再加上自己的私钥签名认证。
4. 服务器为了证明自己的身份，就把证书也发给了客户端（Server Certificate）。
5. Server Done

这样第一个消息往返就结束了（两个 TCP 包），结果是客户端和服务器通过明文共享了三个信息：Client Random、Server Random 和 Server Params。

第二阶段：证书验证同上

第三阶段：主密钥生成

1. 客户端按照密码套件的要求，也生成一个椭圆曲线的公钥（Client Params），用“Client Key Exchange”消息发给服务器。
2. 根据密钥交换算法的两个参数（Client Params、Server Params）用 ECDHE 算法计算出“Pre-Master”，其实也是一个随机数。
3. 现在客户端和服务器手里有了三个随机数：Client Random、Server Random 和 Pre-Master。用这三个作为原始材料，就可以生成用于加密会话的主密钥，叫“Master Secret”。而黑客因为拿不到“Pre-Master”，所以也就得不到主密钥。
4. 有了主密钥和派生的会话密钥，客户端发一个“Change Cipher Spec”，然后再发一个“Finished”消息，把之前所有发送的数据做个摘要，再加密一下，让服务器做个验证。
5. 服务器也发送“Change Cipher Spec”和“Finished”消息，双方都验证加密解密 OK，握手正式结束，后面就收发被加密的 HTTP 请求和响应

**和 RSA 加密算法的区别：**

1. 服务器端在发送 Server Hello 时会发出“Server Key Exchange”消息并携带加密算法参数。
2. 因为使用了 ECDHE，客户端可以不用等到服务器发回“Finished”确认握手完毕，就可以立即发出 HTTP 报文，**省去了一个消息往返的时间浪费**。这个叫“抢跑”，和“TCP Fast Open”有点像，都是不等连接完全建立就提前发应用数据，提高传输的效率。

### TLS1.3 握手

HTTPS 建立连接时除了要做 TCP 握手，还要做 TLS 握手，在 1.2 中会花费两个消息往返（2-RTT），可能导致几十毫秒甚至上百毫秒的延迟，在移动网络中延迟还会更严重。

现在 TLS1.3 密码套件大幅度简化，也就没有必要再像以前那样走复杂的协商流程了，**规定必须使用椭圆曲线算法**。TLS1.3 压缩了以前的“Hello”协商过程，删除了“Key Exchange”消息，把握手时间减少到了“1-RTT”，效率提高了一倍。

![](../../img/网络/HTTP/TLS1.3加密算法.png)
